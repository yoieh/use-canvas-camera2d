{"version":3,"sources":["../../src/hooks/useCanvasCamera2D.tsx","App.tsx","index.tsx"],"names":["ORIGIN","Object","x","y","ratio","diffPoints","p1","p2","addPoints","App","canvasRef","useRef","canvasWidth","canvasHeight","useState","context","setContext","scale","setScale","offset","setOffset","mousePos","setMousePos","viewportTopLeft","setViewportTopLeft","isResetRef","lastMousePosRef","lastOffsetRef","reset","useCallback","mouseMove","lastMousePos","currentMousePos","event","pageY","mouseDiff","prevOffset","mouseUp","document","startPan","getTransformedPoint","transform","useLayoutEffect","renderCtx","offsetDiff","scalePoint","prevVal","useEffect","canvasElem","viewportMousePos","clientY","topLeftCanvasPos","offsetTop","zoom","viewportTopLeftDelta","newViewportTopLeft","useCanvasCamera2D","w","h","color","randomColor","centerRect","setCenterRect","storedTransform","getTransform","canvas","width","setTransform","fillStyle","fillRect","arc","Math","PI","fill","onClick","JSON","stringify","onMouseUp","e","button","nativeEvent","offsetX","offsetY","onMouseDown","ref","id","height","random","toString","slice","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.87e780fe.chunk.js","sourcesContent":["// credit to https://gist.github.com/robinovitch61/483190546bf8f0617d2cd510f3b4b86d\n\nimport {\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useState\n} from 'react'\n\ntype Point = {\n  x: number\n  y: number\n}\n\nconst ORIGIN = Object.freeze({ x: 0, y: 0 })\n\n// adjust to device to avoid blur\nconst { devicePixelRatio: ratio = 1 } = window\n\nfunction diffPoints(p1: Point, p2: Point) {\n  return { x: p1.x - p2.x, y: p1.y - p2.y }\n}\n\nfunction addPoints(p1: Point, p2: Point) {\n  return { x: p1.x + p2.x, y: p1.y + p2.y }\n}\n\nfunction scalePoint(p1: Point, scale: number) {\n  return { x: p1.x / scale, y: p1.y / scale }\n}\n\nconst ZOOM_SENSITIVITY = 500 // bigger for lower zoom per scroll\n\nexport const useCanvasCamera2D = (\n  canvasRef: React.RefObject<HTMLCanvasElement> | null,\n  canvasWidth: number = 0,\n  canvasHeight: number = 0\n) => {\n  const [context, setContext] = useState<CanvasRenderingContext2D | null>(null)\n  const [scale, setScale] = useState<number>(1)\n  const [offset, setOffset] = useState<Point>(ORIGIN)\n  const [mousePos, setMousePos] = useState<Point>(ORIGIN)\n  const [viewportTopLeft, setViewportTopLeft] = useState<Point>(ORIGIN)\n  const isResetRef = useRef<boolean>(false)\n  const lastMousePosRef = useRef<Point>(ORIGIN)\n  const lastOffsetRef = useRef<Point>(ORIGIN)\n\n  // reset\n  const reset = useCallback(\n    (context: CanvasRenderingContext2D) => {\n      if (context && !isResetRef.current) {\n        // adjust for device pixel density\n        context.canvas.width = canvasWidth * ratio\n        context.canvas.height = canvasHeight * ratio\n        context.scale(ratio, ratio)\n        setScale(1)\n\n        // reset state and refs\n        setContext(context)\n        setOffset(ORIGIN)\n        setMousePos(ORIGIN)\n        setViewportTopLeft(ORIGIN)\n        lastOffsetRef.current = ORIGIN\n        lastMousePosRef.current = ORIGIN\n\n        // this thing is so multiple resets in a row don't clear canvas\n        isResetRef.current = true\n      }\n    },\n    [canvasWidth, canvasHeight]\n  )\n\n  // functions for panning\n  const mouseMove = useCallback(\n    (event: MouseEvent) => {\n      if (context) {\n        const lastMousePos = lastMousePosRef.current\n        const currentMousePos = { x: event.pageX, y: event.pageY } // use document so can pan off element\n        lastMousePosRef.current = currentMousePos\n\n        const mouseDiff = diffPoints(currentMousePos, lastMousePos)\n        setOffset((prevOffset) => addPoints(prevOffset, mouseDiff))\n      }\n    },\n    [context]\n  )\n\n  const mouseUp = useCallback(() => {\n    document.removeEventListener('mousemove', mouseMove)\n    document.removeEventListener('mouseup', mouseUp)\n  }, [mouseMove])\n\n  const startPan = useCallback(\n    (event: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\n      document.addEventListener('mousemove', mouseMove)\n      document.addEventListener('mouseup', mouseUp)\n      lastMousePosRef.current = { x: event.pageX, y: event.pageY }\n    },\n    [mouseMove, mouseUp]\n  )\n\n  const getTransformedPoint = useCallback(\n    (x, y) => {\n      if (context) {\n        const transform = context.getTransform()\n        const transformedX = x - transform.e\n        const transformedY = y - transform.f\n        return {\n          x: transformedX,\n          y: transformedY\n        }\n      }\n      return ORIGIN\n    },\n    [context]\n  )\n\n  // setup canvas and set context\n  useLayoutEffect(() => {\n    if (canvasRef?.current) {\n      // get new drawing context\n      const renderCtx = canvasRef.current.getContext('2d')\n\n      if (renderCtx) {\n        reset(renderCtx)\n      }\n    }\n  }, [reset, canvasHeight, canvasWidth])\n\n  // pan when offset or scale changes\n  useLayoutEffect(() => {\n    if (context && lastOffsetRef.current) {\n      const offsetDiff = scalePoint(\n        diffPoints(offset, lastOffsetRef.current),\n        scale\n      )\n      context.translate(offsetDiff.x, offsetDiff.y)\n      setViewportTopLeft((prevVal) => diffPoints(prevVal, offsetDiff))\n      isResetRef.current = false\n    }\n  }, [context, offset, scale])\n\n  // add event listener on canvas for mouse position\n  useEffect(() => {\n    const canvasElem = canvasRef?.current\n    if (canvasElem === null) {\n      return\n    }\n\n    function handleUpdateMouse(event: MouseEvent) {\n      event.preventDefault()\n      if (canvasRef?.current) {\n        const viewportMousePos = { x: event.clientX, y: event.clientY }\n        const topLeftCanvasPos = {\n          x: canvasRef.current.offsetLeft,\n          y: canvasRef.current.offsetTop\n        }\n        setMousePos(diffPoints(viewportMousePos, topLeftCanvasPos))\n      }\n    }\n\n    if (canvasElem) {\n      canvasElem.addEventListener('mousemove', handleUpdateMouse)\n      canvasElem.addEventListener('wheel', handleUpdateMouse)\n    }\n    return () => {\n      if (canvasElem) {\n        canvasElem.removeEventListener('mousemove', handleUpdateMouse)\n        canvasElem.removeEventListener('wheel', handleUpdateMouse)\n      }\n    }\n  }, [])\n\n  // add event listener on canvas for zoom\n  useEffect(() => {\n    const canvasElem = canvasRef?.current\n    if (canvasElem === null) {\n      return\n    }\n\n    // this is tricky. Update the viewport's \"origin\" such that\n    // the mouse doesn't move during scale - the 'zoom point' of the mouse\n    // before and after zoom is relatively the same position on the viewport\n    function handleWheel(event: WheelEvent) {\n      event.preventDefault()\n      if (context) {\n        const zoom = 1 - event.deltaY / ZOOM_SENSITIVITY\n        const viewportTopLeftDelta = {\n          x: (mousePos.x / scale) * (1 - 1 / zoom),\n          y: (mousePos.y / scale) * (1 - 1 / zoom)\n        }\n        const newViewportTopLeft = addPoints(\n          viewportTopLeft,\n          viewportTopLeftDelta\n        )\n\n        context.translate(viewportTopLeft.x, viewportTopLeft.y)\n        context.scale(zoom, zoom)\n        context.translate(-newViewportTopLeft.x, -newViewportTopLeft.y)\n\n        setViewportTopLeft(newViewportTopLeft)\n        setScale(scale * zoom)\n        isResetRef.current = false\n      }\n    }\n\n    if (canvasElem) {\n      canvasElem.addEventListener('wheel', handleWheel)\n    }\n    return () =>\n      canvasElem && canvasElem.removeEventListener('wheel', handleWheel)\n  }, [context, mousePos.x, mousePos.y, viewportTopLeft, scale])\n\n  // update last offset\n  useEffect(() => {\n    lastOffsetRef.current = offset\n  }, [offset])\n\n  return {\n    context,\n    setContext,\n    scale,\n    setScale,\n    offset,\n    setOffset,\n    mousePos,\n    setMousePos,\n    viewportTopLeft,\n    setViewportTopLeft,\n    isResetRef,\n    lastMousePosRef,\n    lastOffsetRef,\n    startPan,\n    reset,\n    mouseMove,\n    mouseUp,\n    getTransformedPoint\n  }\n}\n\nexport default useCanvasCamera2D\n","import React, { useLayoutEffect, useRef, useState } from 'react'\n\nimport { useCanvasCamera2D } from 'use-canvas-camera2d'\n\nconst squareSize: number = 20\n\nconst App = () => {\n  const canvasWidth = 400\n  const canvasHeight = 400\n\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n\n  const {\n    context,\n    viewportTopLeft,\n    scale,\n    offset,\n    startPan,\n    reset,\n    getTransformedPoint\n  } = useCanvasCamera2D(canvasRef, canvasWidth, canvasHeight)\n\n  const [centerRect, setCenterRect] = useState<any>({\n    x: canvasWidth / 2 - squareSize / 2,\n    y: canvasHeight / 2 - squareSize / 2,\n    w: squareSize,\n    h: squareSize,\n    color: randomColor()\n  })\n\n  // draw\n  useLayoutEffect(() => {\n    if (context) {\n      // clear canvas but maintain transform\n      const storedTransform = context.getTransform()\n      context.canvas.width = context?.canvas.width\n      context.setTransform(storedTransform)\n\n      context.fillStyle = centerRect.color\n      context.fillRect(centerRect.x, centerRect.y, squareSize, squareSize)\n      context.arc(viewportTopLeft.x, viewportTopLeft.y, 5, 0, 2 * Math.PI)\n      context.fillStyle = 'red'\n      context.fill()\n    }\n  }, [\n    canvasWidth,\n    canvasHeight,\n    context,\n    scale,\n    offset,\n    viewportTopLeft,\n    centerRect.color,\n    centerRect.x,\n    centerRect.y\n  ])\n\n  return (\n    <div>\n      <button onClick={() => context && reset(context)}>Reset</button>\n\n      <pre>scale: {scale}</pre>\n      <pre>offset: {JSON.stringify(offset)}</pre>\n      <pre>viewportTopLeft: {JSON.stringify(viewportTopLeft)}</pre>\n\n      <canvas\n        onMouseUp={(e) => {\n          if (e.button === 0) {\n            const mousePos = getTransformedPoint(\n              e.nativeEvent.offsetX,\n              e.nativeEvent.offsetY\n            )\n\n            // change center rect color if clicked\n            if (\n              mousePos.x >= centerRect.x &&\n              mousePos.x <= centerRect.x + squareSize &&\n              mousePos.y >= centerRect.y &&\n              mousePos.y <= centerRect.y + squareSize\n            ) {\n              setCenterRect({\n                ...centerRect,\n                color: randomColor()\n              })\n            }\n          }\n        }}\n        onMouseDown={(e) => {\n          // only pan if middle mouse button\n          if (e.button === 1) {\n            startPan(e)\n          }\n        }}\n        ref={canvasRef}\n        id='canvas'\n        width={canvasWidth}\n        height={canvasHeight}\n      ></canvas>\n    </div>\n  )\n}\n\nexport default App\n\nfunction randomColor() {\n  return '#' + Math.random().toString(16).slice(2, 8)\n}\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}